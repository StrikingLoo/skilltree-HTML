<style>
html, body{
	padding:0;
	margin:0;
}
#skilltree {
	width: 90vw;
	height: 90vh;
	border: 0;
}
#panel {
	z-index: 100;
	position:absolute;
	top:0;
	left:0;
	padding:16px;
	border : 1px solid lightgrey;
}
#popin{
	z-index: 200;
	position:absolute;
	left:50%;
	top:50%;
	transform:translate(-50% -50%);
	border:1px solid #ccc;
	padding:16px;
}
#popin:empty{
	display:none;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
<div id="popin"></div>
<div id="skilltree"></div>
<div id="panel">Points: <span id="wallet"></span></div>

Initial code sourced from <a href="https://codepen.io/poppan/pen/RexWgX"> CodePen </a>.
<script>(() => {
	const lockedColor = "#ccc";
	const unlockedColor = "#def";
	const selectedColor = "#33F0C3";

	/* DATASET */
	let nodes = new vis.DataSet([
		{ id: 1, value: 1, level: 3, label: "starting 1" },
		{ id: 2, value: 1, level: 3, label: "starting 2" },
		{ id: 3, value: 1, level: 3, label: "starting 3" },
		{ id: 4, value: 1, level: 2, label: "intermediate 1" },
		{ id: 5, value: 1, level: 2, label: "intermediate 2" },
		{ id: 6, value: 1, level: 1, label: "final" },
	].map(n => { return n}));
	let edges = new vis.DataSet([
		{ from: 1, to: 4, arrows: "to" },
		{ from: 2, to: 4, arrows: "to" },
		{ from: 3, to: 5, arrows: "to" },
		{ from: 4, to: 6, arrows: "to" },
		{ from: 5, to: 6, arrows: "to" },
	]);
	const container = document.getElementById("skilltree");
	const data = {
		nodes: nodes,
		edges: edges
	};
	const options = {
		interaction: {
			selectConnectedEdges: false
		},
		nodes: {
			chosen: false,
			shape: "square",
			size: 12,
			color: lockedColor,
			font: {
				face: "Raleway, Helvetica, Arial",
				size: 14,
				color: "#666"
			},
			borderWidth: 1,
		},
		edges: {
			color: lockedColor,
			dashes: true,
			arrows :{
				to:{
					scaleFactor: 0.5
				}
			}		
		},
		layout: {
			hierarchical: {
				direction: "DU"
			}
		}
	};
	let network = new vis.Network(container, data, options);
	let wallet = 100;

	/* ********************************************************************************* */
	
	/**
		update all graph nodes with selectedParents and subTree Requirements
		change visuals based on status (values / requirements / selected)
	**/
	const buildGraphDisplay = function() {
		//update wallet display
		document.getElementById("wallet").innerHTML = wallet;


		/* recursive subTree (classic) */
		/*
		const getRSubtree = nodeId => {
			let childs = network.getConnectedNodes(nodeId, "from");
			if (childs.length > 0) {
				let subtree = childs;
				for (let i = 0; i < childs.length; i++) {
					let nodeChilds = getSubtree(childs[i]);
					if (nodeChilds) {
						subtree = subtree.concat(nodeChilds);
					}
				}
				return subtree;
			}
			return false;
		};
		*/

		/* SUBTREE */
		/* glitch subtree */
		const getSubtree = nodeId => {
			let childs = network.getConnectedNodes(nodeId, "from");
			for (let i = 0; i < childs.length; i++) {
				childs = childs.concat(network.getConnectedNodes(childs[i], "from"));
			}
			return childs;
		};

		/* glitch parentTree */
		const getParentstree = nodeId => {
			let parents = network.getConnectedNodes(nodeId, "to");
			for (let i = 0; i < parents.length; i++) {
				parents = parents.concat(network.getConnectedNodes(parents[i], "to"));
			}
			return parents;
		};

		nodes.getIds().forEach(nodeId => {
			let currNode = nodes.get(nodeId);
			
			// updating nodes with subtree
			// example using reduce
			currNode.requiredSubtree = getSubtree(nodeId).reduce( (requiredNodes, id) => { 
				const childNode = nodes.get(id);
				(childNode.selected !== true && typeof requiredNodes.find(o => o.id === childNode.id) === "undefined" && requiredNodes.push(childNode));
				return requiredNodes;
			}, []);
			
			// updating nodes with parentspath 
			// example with forEach
			let selectedParents = [];
			getParentstree(nodeId).forEach(node => {
				const parentNode = nodes.get(node);
				(parentNode.selected === true && typeof selectedParents.find(o => o.id === parentNode.id) === "undefined" && selectedParents.push(parentNode));
			});
			currNode.selectedParents = selectedParents;

			// by default mark all as available
			currNode.locked = "";
			//trigger errors for unselected nodes
			if (currNode.selected !== true){
				if (currNode.requiredSubtree.length > 0) {
					// if missing nodes in path mark as locked
					currNode.locked += "To unlock this skill, you're missing the following prerequisites: \n- " + currNode.requiredSubtree.map( n => n.label.replace("\n"," ")).join("\n- ") ;
				}else if (nodes.get(nodeId).value > wallet) {
					// if not enough credit mark as locked
					currNode.locked += "You do not have enough skill points to purchase this skill at the moment. Current total:" + wallet +"\n";
				}
			}
				
			// change node visuals
			currNode.color = {
				background: (currNode.selected === true)?selectedColor:(currNode.locked === "")?unlockedColor:lockedColor,
				highlight: {
					background: (currNode.selected === true)?selectedColor:(currNode.locked === "")?unlockedColor:lockedColor,
				},
			};
			currNode.shapeProperties = (currNode.locked === "") ? { borderDashes : false} : { borderDashes : [6,4] } ;
			currNode.refund = Math.round(currNode.selectedParents.reduce( (parentsRefund, node) => parentsRefund + node.value, currNode.value )*0.9);
			currNode.title = (currNode.selected === true)?  currNode.label +" Refund the acquired skill for "+ currNode.refund +" points" :(currNode.locked === "")? "Acquire "+ currNode.label +" for "+currNode.value +" points" : currNode.locked.replace(/\n/g,"<br/>");
			/*
			currNode.borderWidth = (currNode.selected == true)?2:1;
			currNode.borderWidthSelected = (currNode.selected == true)?2:1;
			*/
			nodes.update(currNode);

			const connectedEdges = network.getConnectedEdges(currNode.id);
			connectedEdges.forEach(id => {
				const edge = edges.get(id);
				if(edge.to == currNode.id){
					edge.dashes = (currNode.selected === true)?false:true;
					edges.update(edge);
				}
			});
			
		});
	};

	/* EVENTS HANDLING */
	/**
		init
	**/
	network.once("stabilized", () => {
		buildGraphDisplay();
	});
	
	/**
		on click, update graph nodes selected status, handle wallet
	**/
	network.on("click", p => {
		if (p.nodes.length) {
			let currNode = nodes.get(p.nodes[0]);
			if (currNode.locked == ""){
				if (currNode.selected == true){
					if (confirm("Refund "+ currNode.refund +" crédits (-10%) pour les compétences :\n- " + currNode.label.replace("\n", "") + (currNode.selectedParents.length > 0 ? "\n- "+ currNode.selectedParents.map( n => n.label.replace("\n"," ")).join("\n- "):""))){
						currNode.selectedParents.forEach( node => {
							node.selected = false;
							nodes.update(node);
						});
						currNode.selected = false;
						wallet += currNode.refund;
					}
				}else{
					if (confirm("Acquire skill:\n- " + currNode.label.replace("\n", "") +"\n Remaining points afterward: " + (wallet - currNode.value) +" skill points")){
						currNode.selected = true;
						wallet -= currNode.value;
					}
				}
				nodes.update(currNode);
				document.getElementById("wallet").innerHTML = wallet;
			}else{
				// No need to alert, those are displayed in tooltips
				// alert(currNode.locked);
			}
			buildGraphDisplay();
		}
	});
})();
</script>
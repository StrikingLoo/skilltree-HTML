<style>
html, body{
	padding:0;
	margin:0;
}
#skilltree {
	width: 90vw;
	height: 90vh;
	border: 0;
}
#popin{
	z-index: 200;
	position:absolute;
	left:50%;
	top:50%;
	transform:translate(-50% -50%);
	border:1px solid #ccc;
	padding:16px;
}
#popin:empty{
	display:none;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
<div style="text-align: center;">
<textarea id="skillsTextArea" style="width: 40%; height: 10em;">1,asd1
2,asd2
3,asd3
4,asdasd4
1,asd1
2,asd2
3,asd3
4,asdasd4</textarea>
<textarea id="edgesTextArea" style="width: 40%; height: 10em;">1,2
2,3
3,4
5,6
6,7
7,8</textarea><br>
<button onclick="initializeNetwork();">Display!</button>
<input type="button" value="Download image" onclick="document.getElementById('canvasImg').click();">
<a id="canvasImg" download="filename"></a>
<div id="popin"></div>
<div id="skilltree"></div>
</div>
Initial code sourced from <a href="https://codepen.io/poppan/pen/RexWgX"> CodePen </a>.
<script>
	
	const lockedColor = "#ccc";
	const unlockedColor = "#def";
	const selectedColor = "#33F0C3";
	
	const options = {
		interaction: {
			selectConnectedEdges: false
		},
		nodes: {
			chosen: false,
			shape: "square",
			size: 12,
			color: lockedColor,
			font: {
				face: "Raleway, Helvetica, Arial",
				size: 14,
				color: "#666"
			},
			borderWidth: 1,
		},
		edges: {
			color: lockedColor,
			dashes: true,
			arrows :{
				to:{
					scaleFactor: 0.5
				}
			}		
		},
		layout: {
			hierarchical: {
				direction: "UD"
			}
		}
	};

	function obtainSkills(){
		var textArea = document.getElementById('skillsTextArea');
		var lines = textArea.value.split('\n');
		var skills = [];

		for (var j = 0; j < lines.length; j++) {
			if(lines[j] != ''){
				values = lines[j].split(',');
				item = {id: j+1, value: 1, level: parseInt(values[0]), label: values[1]};
			    skills.push(item);
			}
		}
		return skills;
	}

	function obtainSkillEdges(){
		var textArea = document.getElementById('edgesTextArea');
		var lines = textArea.value.split('\n');
		var skillEdges = [];

		for (var j = 0; j < lines.length; j++) {
			if(lines[j] != ''){
				values = lines[j].split(',');
				item = { from: parseInt(values[0]), to: parseInt(values[1]), arrows: "to" }
			  	skillEdges.push(item);
		  }
		}
		return skillEdges;
	}

	function buildGraphDisplay(network, nodes, edges){

		/* SUBTREE */
		/* glitch subtree */
		const getSubtree = nodeId => {
			let childs = network.getConnectedNodes(nodeId, "from");
			for (let i = 0; i < childs.length; i++) {
				childs = childs.concat(network.getConnectedNodes(childs[i], "from"));
			}
			return childs;
		};

		/* glitch parentTree */
		const getParentstree = nodeId => {
			let parents = network.getConnectedNodes(nodeId, "to");
			for (let i = 0; i < parents.length; i++) {
				parents = parents.concat(network.getConnectedNodes(parents[i], "to"));
			}
			return parents;
		};

		nodes.getIds().forEach(nodeId => {
			let currNode = nodes.get(nodeId);
			
			// updating nodes with subtree
			// example using reduce
			currNode.requiredSubtree = getSubtree(nodeId).reduce( (requiredNodes, id) => { 
				const childNode = nodes.get(id);
				(childNode.selected !== true && typeof requiredNodes.find(o => o.id === childNode.id) === "undefined" && requiredNodes.push(childNode));
				return requiredNodes;
			}, []);
			
			// updating nodes with parentspath 
			// example with forEach
			let selectedParents = [];
			getParentstree(nodeId).forEach(node => {
				const parentNode = nodes.get(node);
				(parentNode.selected === true && typeof selectedParents.find(o => o.id === parentNode.id) === "undefined" && selectedParents.push(parentNode));
			});
			currNode.selectedParents = selectedParents;

			// by default mark all as available
			currNode.locked = "";
			//trigger errors for unselected nodes
			if (currNode.selected !== true){
				if (currNode.requiredSubtree.length > 0) {
					// if missing nodes in path mark as locked
					currNode.locked += "To unlock this skill, you're missing the following prerequisites: \n- " + currNode.requiredSubtree.map( n => n.label.replace("\n"," ")).join("\n- ") ;
				}
			}
				
			// change node visuals
			currNode.color = {
				background: (currNode.selected === true)?selectedColor:(currNode.locked === "")?unlockedColor:lockedColor,
				highlight: {
					background: (currNode.selected === true)?selectedColor:(currNode.locked === "")?unlockedColor:lockedColor,
				},
			};
			currNode.shapeProperties = (currNode.locked === "") ? { borderDashes : false} : { borderDashes : [6,4] } ;
			currNode.refund = Math.round(currNode.selectedParents.reduce( (parentsRefund, node) => parentsRefund + node.value, currNode.value )*0.9);
			currNode.title = (currNode.selected === true)?  currNode.label +" Refund the acquired skill for "+ currNode.refund +" points" :(currNode.locked === "")? "Acquire "+ currNode.label +" for "+currNode.value +" points" : currNode.locked.replace(/\n/g,"<br/>");

			nodes.update(currNode);

			const connectedEdges = network.getConnectedEdges(currNode.id);
			connectedEdges.forEach(id => {
				const edge = edges.get(id);
				if(edge.to == currNode.id){
					edge.dashes = (currNode.selected === true)?false:true;
					edges.update(edge);
				}
			});
			
		});
	}

	function initializeNetwork(){

	let nodes = new vis.DataSet(obtainSkills()); 
	let edges = new vis.DataSet(obtainSkillEdges());
	const container = document.getElementById("skilltree");
	const data = {
		nodes: nodes,
		edges: edges
	};
	
	let network = new vis.Network(container, data, options);

	/* ********************************************************************************* */
	
	/**
		update all graph nodes with selectedParents and subTree Requirements
		change visuals based on status (values / requirements / selected)
	**/

	/* EVENTS HANDLING */
	network.once("stabilized", () => {
		buildGraphDisplay(network, nodes, edges);
	});
	
	/**
		on click, update graph nodes selected status
	**/
	network.on("click", p => {
		if (p.nodes.length) {
			let currNode = nodes.get(p.nodes[0]);
			if (currNode.locked == ""){
				if (currNode.selected == true){
					if (confirm("Unlearn skill :\n- " + currNode.label.replace("\n", "") + (currNode.selectedParents.length > 0 ? "\n- "+ currNode.selectedParents.map( n => n.label.replace("\n"," ")).join("\n- "):""))){
						currNode.selectedParents.forEach( node => {
							node.selected = false;
							nodes.update(node);
						});
						currNode.selected = false;
					}
				} else {
					if (confirm("Acquire skill:\n- " + currNode.label.replace("\n", ""))){
						currNode.selected = true;
						
					}
				}
				nodes.update(currNode);
			}else{
				// No need to alert, those are displayed in tooltips
				// alert(currNode.locked);
			}
			buildGraphDisplay(network, nodes, edges);
		}
	});
	
	network.on("afterDrawing", function(ctx) {
	  var dataURL = ctx.canvas.toDataURL();
	  document.getElementById('canvasImg').href = dataURL;
	})
	}

	initializeNetwork();



</script>